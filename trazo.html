<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Pr√°ctica de trazos ‚Äî Pauta tipo Lamela</title>
<style>
  :root{
    --panel:#fff; --border:#e5e7eb; --ink:#111827;
    --base:#ef4444;         /* l√≠nea base (roja) */
    --sec:#3b82f6;          /* l√≠neas secundarias (azules) */
    --bg:#f9fafb;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{display:grid;grid-template-rows:auto 1fr;min-height:100%;}
  header{
    position:sticky;top:0;z-index:10;
    display:flex;flex-wrap:wrap;gap:.5rem 1rem;align-items:center;
    padding:.6rem .8rem;background:var(--panel);border-bottom:1px solid var(--border);
  }
  header .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  header label{font-size:.9rem;color:#374151}
  header input[type="text"]{width:4.5rem}
  header input, header select{padding:.35rem .5rem;border:1px solid var(--border);border-radius:.5rem;background:#fff}
  header button{
    border:1px solid var(--border);background:#fff;border-radius:.6rem;padding:.45rem .65rem;cursor:pointer
  }
  header button:active{transform:translateY(1px)}
  #board{position:relative;inset:0;overflow:hidden}
  canvas{display:block;touch-action:none; background:#fff; margin:auto; box-shadow:0 6px 18px rgba(0,0,0,.06); border:1px solid var(--border); border-radius:12px}
  .footer{
    position:fixed;left:50%;transform:translateX(-50%);bottom:.6rem;opacity:.6;font-size:.8rem;pointer-events:none
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="group">
      <label>Pauta</label>
      <select id="pauta">
        <option value="2.5">2.5 mm</option>
        <option value="3" selected>3 mm</option>
        <option value="4">4 mm</option>
      </select>
      <label>Margen</label>
      <select id="margen">
        <option value="0" selected>Sin margen</option>
        <option value="10">10 mm</option>
        <option value="15">15 mm</option>
      </select>
      <label>Color</label>
      <select id="colorPauta">
        <option value="clasica" selected>Cl√°sica (azul/rojo)</option>
        <option value="suave">Suave</option>
        <option value="alto">Alto contraste</option>
      </select>
      <button id="togglePauta" title="Mostrar/ocultar pauta">üëÅÔ∏è Pauta</button>
    </div>
    <div class="group">
      <label>Herramienta</label>
      <select id="tool">
        <option value="pen" selected>L√°piz</option>
        <option value="eraser">Goma</option>
      </select>
      <label>Grosor</label>
      <input type="range" id="size" min="1" max="16" value="6" />
      <button id="undo" title="Deshacer">‚Ü∂</button>
      <button id="redo" title="Rehacer">‚Ü∑</button>
      <button id="clear" title="Limpiar todo">üóëÔ∏è</button>
      <button id="save" title="Descargar PNG">‚¨áÔ∏è PNG</button>
    </div>
    <div class="group">
      <label>Letra gu√≠a</label>
      <input id="ghostChar" type="text" maxlength="2" value="a" />
      <label>Tama√±o</label>
      <input id="ghostSize" type="range" min="40" max="300" value="160" />
      <button id="toggleGhost" title="Mostrar/ocultar letra gu√≠a">üëÅÔ∏è Letra</button>
      <button id="centerGhost" title="Centrar gu√≠a">‚§¢ Centrar</button>
    </div>
  </header>

  <main id="board">
    <canvas id="pautaCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
    <canvas id="ghostCanvas"></canvas>
  </main>
  <div class="footer">Pellizca/zoom del navegador desactivado sobre el lienzo para evitar scroll accidental.</div>
</div>

<script>
(() => {
  // ===== Utilidades =====
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const PX_PER_MM = 96/25.4; // ~3.78 px/mm en CSS p√≠xel a 96dpi (escala luego por DPR)
  const $ = sel => document.querySelector(sel);
  const pautaSel = $('#pauta'), margenSel = $('#margen'), colorPautaSel = $('#colorPauta');
  const toolSel = $('#tool'), sizeRange = $('#size');
  const undoBtn = $('#undo'), redoBtn = $('#redo'), clearBtn = $('#clear'), saveBtn = $('#save');
  const togglePautaBtn = $('#togglePauta');
  const ghostChar = $('#ghostChar'), ghostSize = $('#ghostSize');
  const toggleGhostBtn = $('#toggleGhost'), centerGhostBtn = $('#centerGhost');

  const pautaCv = $('#pautaCanvas');
  const drawCv  = $('#drawCanvas');
  const ghostCv = $('#ghostCanvas');
  const cvs = [pautaCv, drawCv, ghostCv];

  let showPauta = true;
  let showGhost = true;

  // Tama√±o responsivo con buen escalado
  function fitCanvases() {
    // margen visual alrededor
    const vw = Math.min(window.innerWidth, 1200);
    const vh = Math.min(window.innerHeight - 84, 1600);
    const cssW = vw - 16, cssH = vh - 16;
    cvs.forEach(cv => {
      cv.width  = Math.floor(cssW * DPR);
      cv.height = Math.floor(cssH * DPR);
      cv.style.width  = cssW + 'px';
      cv.style.height = cssH + 'px';
    });
    drawPauta();
    drawGhost();
    redraw();
  }
  window.addEventListener('resize', fitCanvases, {passive:true});

  // ===== Pauta tipo "Lamela" =====
  function getPalette(mode){
    if(mode==='suave') return {base:'#f87171', sec:'#93c5fd', margin:'#22c55e33'};
    if(mode==='alto')  return {base:'#dc2626', sec:'#1d4ed8', margin:'#16a34a'};
    return {base:getComputedStyle(document.documentElement).getPropertyValue('--base').trim(),
            sec: getComputedStyle(document.documentElement).getPropertyValue('--sec').trim(),
            margin:'#10b981'};
  }

  function drawPauta(){
    const ctx = pautaCv.getContext('2d');
    ctx.clearRect(0,0,pautaCv.width,pautaCv.height);
    if(!showPauta) return;

    const spacingMM = parseFloat(pautaSel.value); // distancia entre l√≠neas dentro del grupo
    const groupGap = spacingMM * PX_PER_MM * DPR;
    const marginMM = parseFloat(margenSel.value);
    const marginPx = marginMM * PX_PER_MM * DPR;
    const {base, sec, margin} = getPalette(colorPautaSel.value);

    // fondo
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,pautaCv.width,pautaCv.height);

    // margen vertical (si procede)
    if(marginPx>0){
      ctx.strokeStyle = margin; ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      ctx.moveTo(marginPx, 0);
      ctx.lineTo(marginPx, pautaCv.height);
      ctx.stroke();
    }

    // Dibujar grupos de 4 l√≠neas horizontales: (ascendentes) sec ‚Äî ‚Äútecho‚Äù sec ‚Äî base roja ‚Äî descendentes sec
    ctx.lineWidth = 1 * DPR;
    const topPad = 20 * DPR;
    let y = topPad;

    // Ajuste para cubrir toda el √°rea
    while (y < pautaCv.height - topPad){
      // L√≠nea 1 (ascendentes)
      ctx.strokeStyle = sec; ctx.setLineDash([]);
      lineH(y);              y += groupGap;
      // L√≠nea 2 (techo)
      lineH(y);              y += groupGap;
      // L√≠nea 3 (base, roja y algo m√°s gruesa)
      ctx.strokeStyle = base; ctx.lineWidth = 1.5 * DPR;
      lineH(y);              y += groupGap;
      ctx.lineWidth = 1 * DPR;
      // L√≠nea 4 (descendentes)
      ctx.strokeStyle = sec;
      lineH(y);              y += groupGap * 1.6; // peque√±o espacio entre grupos
    }

    function lineH(ypos){
      ctx.beginPath();
      ctx.moveTo(0, ypos);
      ctx.lineTo(pautaCv.width, ypos);
      ctx.stroke();
    }
  }

  // ===== Dibujo libre (l√°piz/goma) con suavizado =====
  const ctxDraw = drawCv.getContext('2d');
  let drawing = false, last = null, points = [];
  const history = []; let redoStack = [];

  function setComposite(){
    ctxDraw.globalCompositeOperation = (toolSel.value==='eraser') ? 'destination-out' : 'source-over';
  }

  function redraw() {
    // redibuja todas las trazadas almacenadas (en caso de resize)
    ctxDraw.clearRect(0,0,drawCv.width,drawCv.height);
    const snap = history.flat(); // array de trazos
    snap.forEach(stroke => {
      ctxDraw.save();
      ctxDraw.lineJoin = ctxDraw.lineCap = 'round';
      ctxDraw.lineWidth = stroke.size;
      ctxDraw.strokeStyle = stroke.color;
      ctxDraw.globalCompositeOperation = stroke.mode;
      drawStroke(stroke.path);
      ctxDraw.restore();
    });
  }

  function drawStroke(path){
    if(path.length<2){ // punto
      const p=path[0];
      ctxDraw.beginPath(); ctxDraw.arc(p.x,p.y,ctxDraw.lineWidth/2,0,Math.PI*2); ctxDraw.fill();
      return;
    }
    ctxDraw.beginPath();
    // Suavizado con curvas cuadr√°ticas
    for(let i=0;i<path.length-1;i++){
      const p0 = path[i], p1 = path[i+1];
      const mx = (p0.x + p1.x)/2, my = (p0.y + p1.y)/2;
      if(i===0) ctxDraw.moveTo(p0.x, p0.y);
      ctxDraw.quadraticCurveTo(p0.x, p0.y, mx, my);
    }
    ctxDraw.stroke();
  }

  function pointerPos(e){
    const rect = drawCv.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top)  * DPR;
    return {x,y};
  }

  function startDraw(e){
    e.preventDefault();
    drawing = true; redoStack = [];
    last = pointerPos(e);
    points = [last];
    ctxDraw.save();
    setComposite();
    ctxDraw.lineJoin = ctxDraw.lineCap = 'round';
    ctxDraw.lineWidth = parseFloat(sizeRange.value) * DPR;
    ctxDraw.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim();
  }
  function moveDraw(e){
    if(!drawing) return;
    const p = pointerPos(e);
    points.push(p);
    // Dibujo incremental para feedback fluido
    ctxDraw.beginPath();
    const prev = points[points.length-2];
    const mx = (prev.x + p.x)/2, my = (prev.y + p.y)/2;
    ctxDraw.quadraticCurveTo(prev.x, prev.y, mx, my);
    ctxDraw.stroke();
  }
  function endDraw(){
    if(!drawing) return;
    drawing = false;
    // guarda trazo en historial
    history.push([{
      mode: ctxDraw.globalCompositeOperation,
      size: ctxDraw.lineWidth,
      color: ctxDraw.strokeStyle,
      path: points.slice()
    }]);
    ctxDraw.restore();
  }

  // Pointer Events (v√°lido para rat√≥n/t√°ctil/pen). iOS OK.
  ['pointerdown','pointermove','pointerup','pointercancel','pointerleave'].forEach(ev=>{
    drawCv.addEventListener(ev, e=>{
      if(ev==='pointerdown') startDraw(e);
      else if(ev==='pointermove') moveDraw(e);
      else endDraw(e);
    }, {passive:false});
  });

  // Deshacer/rehacer/limpiar
  undoBtn.addEventListener('click', ()=>{
    if(!history.length) return;
    const last = history.pop();
    redoStack.push(last);
    redraw();
  });
  redoBtn.addEventListener('click', ()=>{
    if(!redoStack.length) return;
    const item = redoStack.pop();
    history.push(item);
    redraw();
  });
  clearBtn.addEventListener('click', ()=>{
    history.length = 0; redoStack.length = 0;
    ctxDraw.clearRect(0,0,drawCv.width,drawCv.height);
  });

  toolSel.addEventListener('change', setComposite);
  sizeRange.addEventListener('input', ()=>{/* din√°mico */});

  // Guardar PNG (composici√≥n pauta + trazos + gu√≠a)
  saveBtn.addEventListener('click', ()=>{
    const off = document.createElement('canvas');
    off.width = pautaCv.width; off.height = pautaCv.height;
    const octx = off.getContext('2d');
    // fondo blanco
    octx.fillStyle = '#fff'; octx.fillRect(0,0,off.width,off.height);
    if(showPauta) octx.drawImage(pautaCv,0,0);
    octx.drawImage(ghostCv,0,0);
    octx.drawImage(drawCv,0,0);
    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = 'trazos-pauta.png';
    a.click();
  });

  togglePautaBtn.addEventListener('click', ()=>{
    showPauta = !showPauta; drawPauta();
  });
  pautaSel.addEventListener('change', drawPauta);
  margenSel.addEventListener('change', drawPauta);
  colorPautaSel.addEventListener('change', drawPauta);

  // ===== Letra gu√≠a (punteada) =====
  function drawGhost(){
    const ctx = ghostCv.getContext('2d');
    ctx.clearRect(0,0,ghostCv.width,ghostCv.height);
    if(!showGhost) return;
    const txt = ghostChar.value || '';
    if(!txt.trim()) return;

    const fontPx = parseInt(ghostSize.value,10) * DPR;
    ctx.save();
    ctx.font = `normal ${fontPx}px "Comic Sans MS", "Bradley Hand", "Segoe Print", system-ui, sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#6b7280';
    ctx.lineWidth = Math.max(1, Math.round(fontPx*0.06));
    ctx.setLineDash([8*DPR, 6*DPR]);

    const cx = ghostCv.width/2, cy = ghostCv.height/2;
    ctx.strokeText(txt, cx, cy);
    ctx.restore();
  }
  ghostChar.addEventListener('input', drawGhost);
  ghostSize.addEventListener('input', drawGhost);
  toggleGhostBtn.addEventListener('click', ()=>{ showGhost = !showGhost; drawGhost(); });
  centerGhostBtn.addEventListener('click', drawGhost);

  // ===== Init =====
  fitCanvases();
})();
</script>
</body>
</html>